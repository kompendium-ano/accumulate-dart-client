import 'package:accumulate_api/src/protocol/encoding.dart';
import 'package:accumulate_api/src/protocol/enums.dart';

// DO NOT EDIT. Generated by generate-sdk.sh.

abstract class Signature extends Marshallable {
  int type();

  static Signature fromJson(Map<String, dynamic> json) {
    var type = json['type'] as String;
    switch (SignatureType.byName(type)) {
      case SignatureType.ED25519:
        return ED25519Signature.fromJson(json);
      case SignatureType.LegacyED25519:
        return LegacyED25519Signature.fromJson(json);
      default:
        throw new ArgumentError("Unknown SignatureType '${type}'");
    }
  }
}

abstract class TransactionPayload extends Marshallable {
  int type();

  static TransactionPayload fromJson(Map<String, dynamic> json) {
    var type = json['type'] as String;
    switch (TransactionType.byName(type)) {
      case TransactionType.AddCredits:
        return AddCredits.fromJson(json);
      case TransactionType.BurnTokens:
        return BurnTokens.fromJson(json);
      case TransactionType.CreateDataAccount:
        return CreateDataAccount.fromJson(json);
      case TransactionType.CreateIdentity:
        return CreateIdentity.fromJson(json);
      case TransactionType.CreateKeyBook:
        return CreateKeyBook.fromJson(json);
      case TransactionType.CreateKeyPage:
        return CreateKeyPage.fromJson(json);
      case TransactionType.CreateToken:
        return CreateToken.fromJson(json);
      case TransactionType.CreateTokenAccount:
        return CreateTokenAccount.fromJson(json);
      case TransactionType.IssueTokens:
        return IssueTokens.fromJson(json);
      case TransactionType.SendTokens:
        return SendTokens.fromJson(json);
      case TransactionType.SignPending:
        return SignPending.fromJson(json);
      case TransactionType.UpdateKeyPage:
        return UpdateKeyPage.fromJson(json);
      case TransactionType.WriteData:
        return WriteData.fromJson(json);
      case TransactionType.WriteDataTo:
        return WriteDataTo.fromJson(json);
      default:
        throw new ArgumentError("Unknown TransactionType '${type}'");
    }
  }
}

class AddCredits extends TransactionPayload {
  AddCredits({required this.recipient, required this.amount, });
  
  String recipient;
  int amount;
  
  int type() {
    return TransactionType.AddCredits;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUtf8(2, this.recipient);
    writer.writeUint(3, this.amount);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'recipient': this.recipient,
    'amount': this.amount,
  };

  AddCredits.fromJson(Map<String, dynamic> json)
    : recipient = json['recipient'] as String,
      amount = json['amount'] as int? ?? 0;
}

class BurnTokens extends TransactionPayload {
  BurnTokens({required this.amount, });
  
  BigInt amount;
  
  int type() {
    return TransactionType.BurnTokens;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeBigInt(2, this.amount);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'amount': this.amount.toRadixString(10),
  };

  BurnTokens.fromJson(Map<String, dynamic> json)
    : amount = BigInt.parse(json['amount']);
}

class CreateDataAccount extends TransactionPayload {
  CreateDataAccount({required this.url, this.keyBookUrl, this.managerKeyBookUrl, this.scratch, });
  
  String url;
  String? keyBookUrl;
  String? managerKeyBookUrl;
  bool? scratch;
  
  int type() {
    return TransactionType.CreateDataAccount;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUtf8(2, this.url);
    writer.writeUtf8(3, this.keyBookUrl);
    writer.writeUtf8(4, this.managerKeyBookUrl);
    writer.writeBool(5, this.scratch);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'url': this.url,
    'keyBookUrl': this.keyBookUrl,
    'managerKeyBookUrl': this.managerKeyBookUrl,
    'scratch': this.scratch,
  };

  CreateDataAccount.fromJson(Map<String, dynamic> json)
    : url = json['url'] as String,
      keyBookUrl = json['keyBookUrl'] as String?,
      managerKeyBookUrl = json['managerKeyBookUrl'] as String?,
      scratch = json['scratch'] as bool?;
}

class CreateIdentity extends TransactionPayload {
  CreateIdentity({required this.url, required this.publicKey, this.keyBookName, this.keyPageName, this.manager, });
  
  String url;
  String publicKey;
  String? keyBookName;
  String? keyPageName;
  String? manager;
  
  int type() {
    return TransactionType.CreateIdentity;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUtf8(2, this.url);
    writer.writeHex(3, this.publicKey);
    writer.writeUtf8(4, this.keyBookName);
    writer.writeUtf8(5, this.keyPageName);
    writer.writeUtf8(6, this.manager);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'url': this.url,
    'publicKey': this.publicKey,
    'keyBookName': this.keyBookName,
    'keyPageName': this.keyPageName,
    'manager': this.manager,
  };

  CreateIdentity.fromJson(Map<String, dynamic> json)
    : url = json['url'] as String,
      publicKey = json['publicKey'] as String,
      keyBookName = json['keyBookName'] as String?,
      keyPageName = json['keyPageName'] as String?,
      manager = json['manager'] as String?;
}

class CreateKeyBook extends TransactionPayload {
  CreateKeyBook({required this.url, required this.pages, this.manager, });
  
  String url;
  List<String>? pages;
  String? manager;
  
  int type() {
    return TransactionType.CreateKeyBook;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUtf8(2, this.url);
    this.pages?.forEach((var value) => writer.writeUtf8(3, value));
    writer.writeUtf8(4, this.manager);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'url': this.url,
    'pages': this.pages?.map((v) => v).toList(),
    'manager': this.manager,
  };

  CreateKeyBook.fromJson(Map<String, dynamic> json)
    : url = json['url'] as String,
      pages = (json['pages'] as List<dynamic>? ?? []).map((v) => v as String).toList(),
      manager = json['manager'] as String?;
}

class CreateKeyPage extends TransactionPayload {
  CreateKeyPage({required this.url, required this.keys, this.manager, });
  
  String url;
  List<KeySpecParams>? keys;
  String? manager;
  
  int type() {
    return TransactionType.CreateKeyPage;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUtf8(2, this.url);
    this.keys?.forEach((var value) => writer.writeValue(3, value));
    writer.writeUtf8(4, this.manager);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'url': this.url,
    'keys': this.keys?.map((v) => v.toJson()).toList(),
    'manager': this.manager,
  };

  CreateKeyPage.fromJson(Map<String, dynamic> json)
    : url = json['url'] as String,
      keys = (json['keys'] as List<dynamic>? ?? []).map((v) => KeySpecParams.fromJson(v)).toList(),
      manager = json['manager'] as String?;
}

class CreateToken extends TransactionPayload {
  CreateToken({required this.url, this.keyBookUrl, required this.symbol, required this.precision, this.properties, this.initialSupply, this.hasSupplyLimit, this.manager, });
  
  String url;
  String? keyBookUrl;
  String symbol;
  int precision;
  String? properties;
  BigInt? initialSupply;
  bool? hasSupplyLimit;
  String? manager;
  
  int type() {
    return TransactionType.CreateToken;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUtf8(2, this.url);
    writer.writeUtf8(3, this.keyBookUrl);
    writer.writeUtf8(4, this.symbol);
    writer.writeUint(5, this.precision);
    writer.writeUtf8(6, this.properties);
    writer.writeBigInt(7, this.initialSupply);
    writer.writeBool(8, this.hasSupplyLimit);
    writer.writeUtf8(9, this.manager);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'url': this.url,
    'keyBookUrl': this.keyBookUrl,
    'symbol': this.symbol,
    'precision': this.precision,
    'properties': this.properties,
    'initialSupply': this.initialSupply?.toRadixString(10),
    'hasSupplyLimit': this.hasSupplyLimit,
    'manager': this.manager,
  };

  CreateToken.fromJson(Map<String, dynamic> json)
    : url = json['url'] as String,
      keyBookUrl = json['keyBookUrl'] as String?,
      symbol = json['symbol'] as String,
      precision = json['precision'] as int? ?? 0,
      properties = json['properties'] as String?,
      initialSupply = BigInt.parse(json['initialSupply']),
      hasSupplyLimit = json['hasSupplyLimit'] as bool?,
      manager = json['manager'] as String?;
}

class CreateTokenAccount extends TransactionPayload {
  CreateTokenAccount({required this.url, required this.tokenUrl, this.keyBookUrl, this.scratch, this.manager, });
  
  String url;
  String tokenUrl;
  String? keyBookUrl;
  bool? scratch;
  String? manager;
  
  int type() {
    return TransactionType.CreateTokenAccount;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUtf8(2, this.url);
    writer.writeUtf8(3, this.tokenUrl);
    writer.writeUtf8(4, this.keyBookUrl);
    writer.writeBool(5, this.scratch);
    writer.writeUtf8(6, this.manager);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'url': this.url,
    'tokenUrl': this.tokenUrl,
    'keyBookUrl': this.keyBookUrl,
    'scratch': this.scratch,
    'manager': this.manager,
  };

  CreateTokenAccount.fromJson(Map<String, dynamic> json)
    : url = json['url'] as String,
      tokenUrl = json['tokenUrl'] as String,
      keyBookUrl = json['keyBookUrl'] as String?,
      scratch = json['scratch'] as bool?,
      manager = json['manager'] as String?;
}

class DataEntry extends Marshallable {
  DataEntry({this.extIds, this.data, });
  
  List<String>? extIds;
  String? data;
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    this.extIds?.forEach((var value) => writer.writeHex(1, value));
    writer.writeHex(2, this.data);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'extIds': this.extIds?.map((v) => v).toList(),
    'data': this.data,
  };

  DataEntry.fromJson(Map<String, dynamic> json)
    : extIds = (json['extIds'] as List<dynamic>? ?? []).map((v) => v as String).toList(),
      data = json['data'] as String?;
}

class ED25519Signature extends Signature {
  ED25519Signature({required this.publicKey, required this.signature, });
  
  String publicKey;
  String signature;
  
  int type() {
    return SignatureType.ED25519;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeHex(2, this.publicKey);
    writer.writeHex(3, this.signature);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'publicKey': this.publicKey,
    'signature': this.signature,
  };

  ED25519Signature.fromJson(Map<String, dynamic> json)
    : publicKey = json['publicKey'] as String,
      signature = json['signature'] as String;
}

class Envelope extends Marshallable {
  Envelope({required this.signatures, this.txHash, this.transaction, });
  
  List<Signature>? signatures;
  String? txHash;
  Transaction? transaction;
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    this.signatures?.forEach((var value) => writer.writeValue(1, value));
    writer.writeHex(2, this.txHash);
    writer.writeValue(3, this.transaction);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'signatures': this.signatures?.map((v) => v.toJson()).toList(),
    'txHash': this.txHash,
    'transaction': this.transaction?.toJson(),
  };

  Envelope.fromJson(Map<String, dynamic> json)
    : signatures = (json['signatures'] as List<dynamic>? ?? []).map((v) => Signature.fromJson(v)).toList(),
      txHash = json['txHash'] as String?,
      transaction = Transaction.fromJson(json['transaction']);
}

class IssueTokens extends TransactionPayload {
  IssueTokens({required this.recipient, required this.amount, });
  
  String recipient;
  BigInt amount;
  
  int type() {
    return TransactionType.IssueTokens;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUtf8(2, this.recipient);
    writer.writeBigInt(3, this.amount);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'recipient': this.recipient,
    'amount': this.amount.toRadixString(10),
  };

  IssueTokens.fromJson(Map<String, dynamic> json)
    : recipient = json['recipient'] as String,
      amount = BigInt.parse(json['amount']);
}

class KeySpecParams extends Marshallable {
  KeySpecParams({required this.publicKey, });
  
  String publicKey;
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeHex(1, this.publicKey);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'publicKey': this.publicKey,
  };

  KeySpecParams.fromJson(Map<String, dynamic> json)
    : publicKey = json['publicKey'] as String;
}

class LegacyED25519Signature extends Signature {
  LegacyED25519Signature({required this.nonce, required this.publicKey, required this.signature, });
  
  int nonce;
  String publicKey;
  String signature;
  
  int type() {
    return SignatureType.LegacyED25519;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUint(2, this.nonce);
    writer.writeHex(3, this.publicKey);
    writer.writeHex(4, this.signature);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'nonce': this.nonce,
    'publicKey': this.publicKey,
    'signature': this.signature,
  };

  LegacyED25519Signature.fromJson(Map<String, dynamic> json)
    : nonce = json['nonce'] as int? ?? 0,
      publicKey = json['publicKey'] as String,
      signature = json['signature'] as String;
}

class SendTokens extends TransactionPayload {
  SendTokens({this.hash, this.meta, required this.to, });
  
  String? hash;
  dynamic? meta;
  List<TokenRecipient>? to;
  
  int type() {
    return TransactionType.SendTokens;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeHash(2, this.hash);
    writer.writeRawJson(3, this.meta);
    this.to?.forEach((var value) => writer.writeValue(4, value));
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'hash': this.hash,
    'meta': this.meta,
    'to': this.to?.map((v) => v.toJson()).toList(),
  };

  SendTokens.fromJson(Map<String, dynamic> json)
    : hash = json['hash'] as String?,
      meta = json['meta'] as dynamic?,
      to = (json['to'] as List<dynamic>? ?? []).map((v) => TokenRecipient.fromJson(v)).toList();
}

class SignPending extends TransactionPayload {
  int type() {
    return TransactionType.SignPending;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
  };

  SignPending.fromJson(Map<String, dynamic> json);
}

class TokenRecipient extends Marshallable {
  TokenRecipient({required this.url, required this.amount, });
  
  String url;
  BigInt amount;
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUtf8(1, this.url);
    writer.writeBigInt(2, this.amount);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'url': this.url,
    'amount': this.amount.toRadixString(10),
  };

  TokenRecipient.fromJson(Map<String, dynamic> json)
    : url = json['url'] as String,
      amount = BigInt.parse(json['amount']);
}

class Transaction extends Marshallable {
  Transaction({required this.transactionHeader, required this.body, });
  
  TransactionHeader transactionHeader;
  TransactionPayload body;
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeValue(1, this.transactionHeader);
    writer.writeValue(2, this.body);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'origin': this.transactionHeader.origin,
    'keyPageHeight': this.transactionHeader.keyPageHeight,
    'keyPageIndex': this.transactionHeader.keyPageIndex,
    'nonce': this.transactionHeader.nonce,
    'body': this.body.toJson(),
  };

  Transaction.fromJson(Map<String, dynamic> json)
    : transactionHeader = TransactionHeader.fromJson(json),
      body = TransactionPayload.fromJson(json['body']);
}

class TransactionHeader extends Marshallable {
  TransactionHeader({required this.origin, required this.keyPageHeight, required this.keyPageIndex, required this.nonce, });
  
  String origin;
  int keyPageHeight;
  int keyPageIndex;
  int nonce;
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUtf8(1, this.origin);
    writer.writeUint(2, this.keyPageHeight);
    writer.writeUint(3, this.keyPageIndex);
    writer.writeUint(4, this.nonce);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'origin': this.origin,
    'keyPageHeight': this.keyPageHeight,
    'keyPageIndex': this.keyPageIndex,
    'nonce': this.nonce,
  };

  TransactionHeader.fromJson(Map<String, dynamic> json)
    : origin = json['origin'] as String,
      keyPageHeight = json['keyPageHeight'] as int? ?? 0,
      keyPageIndex = json['keyPageIndex'] as int? ?? 0,
      nonce = json['nonce'] as int? ?? 0;
}

class UpdateKeyPage extends TransactionPayload {
  UpdateKeyPage({required this.operation, this.key, this.newKey, this.owner, this.threshold, });
  
  int operation;
  String? key;
  String? newKey;
  String? owner;
  int? threshold;
  
  int type() {
    return TransactionType.UpdateKeyPage;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUint(2, this.operation);
    writer.writeHex(3, this.key);
    writer.writeHex(4, this.newKey);
    writer.writeUtf8(5, this.owner);
    writer.writeUint(6, this.threshold);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'operation': KeyPageOperation.name(this.operation),
    'key': this.key,
    'newKey': this.newKey,
    'owner': this.owner,
    'threshold': this.threshold,
  };

  UpdateKeyPage.fromJson(Map<String, dynamic> json)
    : operation = KeyPageOperation.byName(json['operation']),
      key = json['key'] as String?,
      newKey = json['newKey'] as String?,
      owner = json['owner'] as String?,
      threshold = json['threshold'] as int? ?? 0;
}

class WriteData extends TransactionPayload {
  WriteData({required this.entry, });
  
  DataEntry entry;
  
  int type() {
    return TransactionType.WriteData;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeValue(2, this.entry);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'entry': this.entry.toJson(),
  };

  WriteData.fromJson(Map<String, dynamic> json)
    : entry = DataEntry.fromJson(json['entry']);
}

class WriteDataTo extends TransactionPayload {
  WriteDataTo({required this.recipient, required this.entry, });
  
  String recipient;
  DataEntry entry;
  
  int type() {
    return TransactionType.WriteDataTo;
  }
  
  List<int> marshalBinary() {
    var writer = ProtocolWriter();
    writer.writeUint(1, this.type());
    writer.writeUtf8(2, this.recipient);
    writer.writeValue(3, this.entry);
    return writer.msg;
  }

  Map<String, dynamic> toJson() => {
    'recipient': this.recipient,
    'entry': this.entry.toJson(),
  };

  WriteDataTo.fromJson(Map<String, dynamic> json)
    : recipient = json['recipient'] as String,
      entry = DataEntry.fromJson(json['entry']);
}